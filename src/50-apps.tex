\renewcommand\thechapter{\CYRA\arabic{chapter}}
\renewcommand\appendixname{Приложение~А}
\chapter*{~~Модель сборочной линии}\label{chap:a}
\addcontentsline{toc}{chapter}{\appendixname~~Модель сборочной линии}
\renewcommand{\thefigure}{\CYRA\arabic{figure}}

Листинг~\ref{lst:line} содержит реализацию модели сборочной линии.

\begin{lstlisting}[language=Golang,caption={Реализация модели сборочной линии},label=lst:line]
	func (assembly *AssemblyLine) Bind(conf interface{}, events ...*imcore.ConcreteEvent) {
		assembly.checkConfig(conf)
		if assembly.remain == nil {
			assembly.remain = make(map[*imcore.ConcreteEvent][]*imcore.ConcreteEvent)
			assembly.complete = make(map[*imcore.ConcreteEvent][]*imcore.ConcreteEvent)
		}
		for _, e := range events {
			assembly.remain[e] = events
		}
		assembly.initEvent(conf, events...)
	}

	func (assembly *AssemblyLine) Constrain(event *imcore.ConcreteEvent) (int64, bool) {
		lineNum, position, onLine := assembly.findProduct(event.ProductSN, event.ProductType)
		if onLine {
			if assembly.lineReady(lineNum) {
				return assembly.lines[lineNum].maxTime, true
			} else if !assembly.containsEvent(position, event) {
				return assembly.lines[lineNum].maxTime, false
			}
		} else {
			num, canLoad := assembly.canLoad()
			if !canLoad {
				return assembly.lines[0].minTime, false
			}
			lineNum = num
		}
		return assembly.lines[lineNum].minTime, true
	}

	
	func (assembly *AssemblyLine) Done(event *imcore.ConcreteEvent) {
		
		lineNum, _, onLine := assembly.findProduct(event.ProductSN, event.ProductType)
		if event.EventType == imcore.BeginEvent {
			if !onLine {
				
				assembly.loadProduct(event)
			} else {
				if assembly.lineReady(lineNum) {
					assembly.moveLine(lineNum, event)
				}
			}
		} else {
			assembly.finishOperation(event)
		}
		assembly.assertBind(event)
		assembly.complete[event] = assembly.remain[event]
		delete(assembly.remain, event)
	}

	func (assembly *AssemblyLine) assertBind(event *imcore.ConcreteEvent) {
		if _, ok := assembly.remain[event]; !ok {
			panic("Event for assembly line not bound")
		}
	}
  
	func (assembly *AssemblyLine) Clone() imcore.Resource {
		tmp := *assembly
		return &tmp
	}

	func (assembly *AssemblyLine) loadProduct(event *imcore.ConcreteEvent) bool {
		_, position, onLine := assembly.findProduct(event.ProductSN, event.ProductType)
		if !onLine && position != -1 {
			minLine, canLoad := assembly.canLoad()
			if canLoad {
				line := assembly.lines[minLine]
				if !line.stations[0].isWorking && len(assembly.queue) > 0 {
					
					station := line.stations[0]
					if len(assembly.remainEvents[0][makeProduct(event)]) > 0 {
						station.isWorking = true
					}
					station.time = line.minTime
					station.product = assembly.queue[position]
					station.isEmpty = false
					line.stations[0] = station
					assembly.lines[minLine] = line
					
					queue := assembly.queue
					if position < len(queue)-1 {
						queue = append(queue[:position], queue[position+1:]...)
					} else {
						queue = queue[:position]
					}
					assembly.queue = queue
					log.Printf("Line (%d) %s loaded on station 0", minLine, station.product.String())
					return true
				}
			}
		}
		return false
	}

	
	func (assembly *AssemblyLine) moveLine(lineNum int, event *imcore.ConcreteEvent) bool {
		if !assembly.lineReady(lineNum) {
			return false
		}
		line := assembly.lines[lineNum]
		line.minTime = line.maxTime
		
		if !line.stations[len(line.stations)-1].isEmpty {
			log.Printf("Line (%d) %s unloaded from line (timestamp: %d)", lineNum, line.stations[len(line.stations)-1].product.String(), line.minTime)
		}
		for i := len(line.stations) - 1; i > 0; i-- {
			station := line.stations[i]
			prevStation := line.stations[i-1]
			station.product = prevStation.product
			station.isEmpty = prevStation.isEmpty
			station.time = line.minTime
			if !station.isEmpty {
				station.isWorking = true
			}
			prevStation.product = Product{
				SerialNumber: -1,
				TypeName:     "",
			}
			prevStation.isEmpty = true
			prevStation.isWorking = false
			line.stations[i] = station
			line.stations[i-1] = prevStation
			
			if !station.isEmpty {
				log.Printf("Line (%d) %s changing station (%d -> %d)", lineNum, station.product.String(), i-1, i)
			}
		}
		assembly.lines[lineNum] = line
		return true
	}

	func (assembly *AssemblyLine) finishOperation(event *imcore.ConcreteEvent) {
		lineNum, position, onLine := assembly.findProduct(event.ProductSN, event.ProductType)
		if onLine {
			station := assembly.lines[lineNum].stations[position]
			product := makeProduct(event)
			triggers := assembly.remainEvents[position][product]
			for i, trigger := range triggers {
				if trigger == event {
					if i+1 < len(triggers) {
						triggers = append(triggers[:i], triggers[i+1:]...)
					} else {
						triggers = triggers[:i]
					}
					log.Printf("Line (%d) %s changing timestamp (%d)", lineNum, station.product.String(), *event.Value)
					station.time = *event.Value
					if len(triggers) < 1 {
						station.isWorking = false
					}
					
					if assembly.lines[lineNum].maxTime < station.time {
						assembly.lines[lineNum].maxTime = station.time
					}
					assembly.lines[lineNum].stations[position] = station
					assembly.remainEvents[position][product] = triggers
				}
			}
			if !station.isWorking {
				assembly.moveLine(lineNum, event)
			}
		} else {
			panic("Not queued product done!")
		}
	}

	func (assembly *AssemblyLine) findProduct(productSN imcore.ProductSN, productType imcore.ProductTypeName) (int, int, bool) {
		for lineNum, line := range assembly.lines {
			for stationNum, station := range line.stations {
				if station.product.SerialNumber == productSN && station.product.TypeName == productType {
					return lineNum, stationNum, true
				}
			}
		}
		for pos, item := range assembly.queue {
			if item.SerialNumber == productSN && item.TypeName == productType {
				return -1, pos, false
			}
		}
		return -1, -1, false
	}

	func (assembly *AssemblyLine) canLoad() (int, bool) {
		if len(assembly.queue) > 0 && len(assembly.lines) > 0 {
			lineWithMinWorkTime := -1
			assemblyMinWorkTime := int64(0)
			for i, line := range assembly.lines {
				if !line.stations[0].isWorking && line.stations[0].isEmpty {
					if (assemblyMinWorkTime > line.minTime) || (lineWithMinWorkTime == -1) {
						assemblyMinWorkTime = line.minTime
						lineWithMinWorkTime = i
					}
				}
			}
			if lineWithMinWorkTime != -1 {
				return lineWithMinWorkTime, true
			}
		}
		return -1, false
	}

	func (assembly *AssemblyLine) lineReady(lineNum int) bool {
		for i, station := range assembly.lines[lineNum].stations {
			product := Product{station.product.TypeName, station.product.SerialNumber}
			if station.isWorking && !station.isEmpty && len(assembly.remainEvents[i][product]) > 0 {
				return false
			}
		}
		station := assembly.lines[lineNum].stations[0]		
		if !station.isWorking && len(assembly.queue) > 0 && station.isEmpty {
			return false
		}
		return true
	}

\end{lstlisting}

\renewcommand\appendixname{Приложение~В}
\chapter*{~~Модуль отображения логического времени на физическое}\label{chap:b}
\addcontentsline{toc}{chapter}{\appendixname~~Модуль отображения логического времени на физическое}

Листинг~\ref{lst:time} содержит реализацию отображения логического времени на физическое.

\begin{lstlisting}[language=Golang,caption={Реализация отображения логического времени на физическое},label=lst:time]
	func LogicalToPhysTime(physStarts int64, logicalTime int64, config ConverterConfig) (int64, int64) {
		confNum, wasPrinted := checkConfig(config)
	
		if !wasPrinted {
			log.Printf("New config %d: %+v\n", confNum, config)
		} else {
			log.Printf("Found config %d\n", confNum)
		}
		log.Printf("Start time is: %v (%v)", physStarts, time.Unix(physStarts, 0).UTC().Format("02/01/2006 15:04:05"))
		log.Printf("Given logical time is: %v (%v in hours)", logicalTime, logicalTime/secondsInHour)
	
		if logicalTime == 0 {
			first, _ := mapLogicalToPhysTime(physStarts, logicalTime, config, true)
			_, second := mapLogicalToPhysTime(physStarts, logicalTime, config, false)
			return first, second
		} else if logicalTime > 0 {
			return mapLogicalToPhysTime(physStarts, logicalTime, config, false)
		}
		second, first := mapLogicalToPhysTime(physStarts, -logicalTime, config, true)
		return first, second
	}
	
	func mapLogicalToPhysTime(physStarts int64, logicalTime int64, config ConverterConfig, isReverted bool) (int64, int64) {
		curOffset := int64(0)
		curTime := physStarts
		first := int64(0)
		isLeftFound := false
		log.Println(" Logical time | Physical time")
		log.Println("--------------|----------------------------------")
		for curOffset <= logicalTime {
			curDay := timeToDate(curTime, isReverted)
			intervals := config.getSchedule(curTime, isReverted)
	
			if len(intervals) < 1 {
				curTime = nextDay(curTime, isReverted)
				continue
			}
	
			for _, interval := range intervals {
				log.Printf(" %-13v| %v (%v)", curOffset, curTime, time.Unix(curTime, 0).UTC().Format("02/01/2006 15:04:05"))
				curOffset, curTime = interval.appendIntervalDur(curTime, curOffset, curDay, isReverted)
				if curOffset >= logicalTime {
					curTime = appendTime(curTime, logicalTime-curOffset, isReverted)
					if !isLeftFound {
						first = curTime
						curOffset = logicalTime
						isLeftFound = true
						break
					} else {
						break
					}
				}
			}
		}
		log.Println("Result:")
		log.Println("-----------------------------------------------------------")
		log.Printf(" %-13v| [%-19v - %-19v]", logicalTime, first, curTime)
		log.Printf(" %-13v| [%-19v - %-19v]", logicalTime, time.Unix(first, 0).UTC().Format("02/01/2006 15:04:05"), time.Unix(curTime, 0).UTC().Format("02/01/2006 15:04:05"))
		return first, curTime
	}
	
	func (interval WorkInterval) appendIntervalDur(physTime int64, logicalTime int64, day int64, isReverted bool) (int64, int64) {
		if isReverted {
			if (interval.Ends + day) >= physTime {
				logicalTime += physTime - day - interval.Starts
			} else {
				logicalTime += interval.Ends - interval.Starts
			}
			physTime = day + interval.Starts
		} else {
			if (interval.Starts + day) <= physTime {
				logicalTime += interval.Ends - physTime + day
			} else {
				logicalTime += interval.Ends - interval.Starts
			}
			physTime = day + interval.Ends
		}
		return logicalTime, physTime
	}
	
	func (config ConverterConfig) getSchedule(physTime int64, isReverted bool) []WorkInterval {
		currentDay := timeToDate(physTime, isReverted)
	
		scheduleName := config.getTemplateName(currentDay)
		intervals := config.ScheduleForDay.getIntervals(physTime-currentDay, scheduleName, isReverted)
		scheduleName = config.getTemplateName(currentDay - oneDayInSecs)
		prevIntervals := config.ScheduleForDay.getIntervals((physTime-currentDay)+oneDayInSecs, scheduleName, isReverted)
	
		if len(prevIntervals) > 0 {
			for i, interval := range prevIntervals {
				if interval.Starts-oneDayInSecs >= 0 || interval.Ends-oneDayInSecs > 0 {
					prevIntervals[i].Starts = interval.Starts - oneDayInSecs
					prevIntervals[i].Ends = interval.Ends - oneDayInSecs
					intervals = append([]WorkInterval{prevIntervals[i]}, intervals...)
				}
			}
		}
		if isReverted && len(intervals) > 1 {
			last := len(intervals) - 1
			for i := 0; i <= last/2; i++ {
				intervals[i], intervals[last-i] = intervals[last-i], intervals[i]
			}
		}
	
		return intervals
	}
	
	func (schedules ScheduleForDay) getIntervals(physTime int64, scheduleName DayTemplateName, isReverted bool) []WorkInterval {
		result := make([]WorkInterval, 0)
		intervals := schedules[scheduleName]
	
		for _, interval := range intervals {
			if interval.contains(physTime, isReverted) {
				result = append(result, interval)
			}
		}
		return result
	}
	
	func (config ConverterConfig) getTemplateName(date int64) DayTemplateName {
		exception, ok := config.ExceptionDates[date]
		if ok {
			return exception
		}
		if exception != "" {
			return exception
		}
		for item := range config.ScheduleTemplate {
			if item == int(time.Unix(date, 0).UTC().Weekday()) {
				return config.ScheduleTemplate[item]
			}
		}
		panic("No schedule defined")
	}
	
	
\end{lstlisting}